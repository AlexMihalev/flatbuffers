# automatically generated by the FlatBuffers compiler, do not modify

import flatbuffers
import enum


class Color(enum.IntEnum):
    Red = 0
    Green = 1
    Blue = 2
    MIN = Red
    MAX = Blue


class Equipment(enum.IntEnum):
    NONE = 0
    Weapon = 1
    MIN = NONE
    MAX = Weapon

    @property
    def table_type(self):
        return self.table_types()[self]

    @classmethod
    def table_types(cls):
        return {
            cls.Weapon: Weapon
        }


class Vec3(object):
    BYTE_SIZE = 12
    MIN_ALIGN = 4

    def __init__(self, buf, offset):
        self._buf = buf[offset:offset + self.BYTE_SIZE]

    @classmethod
    def create(cls, x=0.0, y=0.0, z=0.0):
        value = cls(bytearray(cls.BYTE_SIZE), 0)
        value.x = x
        value.y = y
        value.z = z
        return value

    @property
    def x(self):
        number_type = flatbuffers.number_types.Float32Flags
        result = flatbuffers.encode.Get(number_type.packer_type, self._buf, 0)
        return number_type.py_type(result)

    @x.setter
    def x(self, value):
        number_type = flatbuffers.number_types.Float32Flags
        flatbuffers.number_types.enforce_number(value, number_type)
        flatbuffers.encode.Write(number_type.packer_type, self._buf, 0, value)

    @property
    def y(self):
        number_type = flatbuffers.number_types.Float32Flags
        result = flatbuffers.encode.Get(number_type.packer_type, self._buf, 4)
        return number_type.py_type(result)

    @y.setter
    def y(self, value):
        number_type = flatbuffers.number_types.Float32Flags
        flatbuffers.number_types.enforce_number(value, number_type)
        flatbuffers.encode.Write(number_type.packer_type, self._buf, 4, value)

    @property
    def z(self):
        number_type = flatbuffers.number_types.Float32Flags
        result = flatbuffers.encode.Get(number_type.packer_type, self._buf, 8)
        return number_type.py_type(result)

    @z.setter
    def z(self, value):
        number_type = flatbuffers.number_types.Float32Flags
        flatbuffers.number_types.enforce_number(value, number_type)
        flatbuffers.encode.Write(number_type.packer_type, self._buf, 8, value)

    def copy_into(self, buf, offset):
        buf[offset:offset + len(self._buf)] = self._buf


class Monster(object):
    VT_POS = 4
    VT_MANA = 6
    VT_HP = 8
    VT_NAME = 10
    VT_INVENTORY = 14
    VT_COLOR = 16
    VT_WEAPONS = 18
    VT_EQUIPPED_TYPE = 20
    VT_EQUIPPED = 22

    def __init__(self, buf, offset):
        self._tab = flatbuffers.table.Table(buf, offset)

    @classmethod
    def from_root(cls, buf, offset=0):
        relative_table_offset = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        return Monster(buf, offset + relative_table_offset)

    @property
    def pos(self):
        offset = self._tab.Offset(self.VT_POS)
        if not offset:
            return None

        offset_in_buf = offset + self._tab.Pos
        return Vec3(self._tab.Bytes, offset_in_buf)

    @property
    def mana(self):
        offset = self._tab.Offset(self.VT_MANA)
        if not offset:
            return 150

        return self._tab.Get(flatbuffers.number_types.Int16Flags, offset + self._tab.Pos)

    @property
    def hp(self):
        offset = self._tab.Offset(self.VT_HP)
        if not offset:
            return 100

        return self._tab.Get(flatbuffers.number_types.Int16Flags, offset + self._tab.Pos)

    @property
    def name(self):
        offset = self._tab.Offset(self.VT_NAME)
        if not offset:
            return None

        return self._tab.String(offset + self._tab.Pos)

    def inventory_item(self, index):
        offset = self._tab.Offset(self.VT_INVENTORY)
        if not offset:
            return 0

        item_offset_in_vector = index * 1
        vector_offset = self._tab.Vector(offset)
        item_offset_in_buf = vector_offset + item_offset_in_vector
        return self._tab.Get(flatbuffers.number_types.Uint8Flags, item_offset_in_buf)

    def inventory_as_numpy(self):
        offset = self._tab.Offset(self.VT_INVENTORY)
        if not offset:
            return 0

        return self._tab.GetVectorAsNumpy(flatbuffers.number_types.Uint8Flags, offset)

    @property
    def inventory_length(self):
        offset = self._tab.Offset(self.VT_INVENTORY)
        if not offset:
            return 0

        return self._tab.VectorLen(offset)

    @property
    def color(self):
        offset = self._tab.Offset(self.VT_COLOR)
        if not offset:
            return 2

        return self._tab.Get(flatbuffers.number_types.Int8Flags, offset + self._tab.Pos)

    def weapons_item(self, index):
        offset = self._tab.Offset(self.VT_WEAPONS)
        if not offset:
            return None

        item_offset_in_vector = index * 4
        vector_offset = self._tab.Vector(offset)
        item_offset_in_buf = self._tab.Indirect(vector_offset + item_offset_in_vector)
        return Weapon(self._tab.Bytes, item_offset_in_buf)

    @property
    def weapons_length(self):
        offset = self._tab.Offset(self.VT_WEAPONS)
        if not offset:
            return 0

        return self._tab.VectorLen(offset)

    @property
    def equipped_type(self):
        offset = self._tab.Offset(self.VT_EQUIPPED_TYPE)
        if not offset:
            return 0

        return Equipment(self._tab.Get(flatbuffers.number_types.Uint8Flags, offset + self._tab.Pos))

    @property
    def equipped(self):
        union_table = self.equipped_union

        if union_table is None:
            return None

        value_type = self.equipped_type.table_type
        return value_type(union_table.Bytes, union_table.Pos)

    @property
    def equipped_union(self):
        offset = self._tab.Offset(self.VT_EQUIPPED)
        if not offset:
            return None

        union_table = flatbuffers.table.Table(bytearray(), 0)
        self._tab.Union(union_table, offset)
        return union_table

    @staticmethod
    def create(fbb, mana, hp, name, inventory, color, weapons, equipped_type, equipped):
        builder = MonsterBuilder(fbb)
        builder.add_equipped(equipped)
        builder.add_weapons(weapons)
        builder.add_inventory(inventory)
        builder.add_name(name)
        builder.add_hp(hp)
        builder.add_mana(mana)
        builder.add_equipped_type(equipped_type)
        builder.add_color(color)
        return builder.finish()


class MonsterBuilder(object):
    def __init__(self, builder):
        self._builder = builder
        builder.StartObject(10)

    def add_pos(self, pos):
        self._builder.Prep(Vec3.MIN_ALIGN, Vec3.BYTE_SIZE)
        self._builder.Pad(Vec3.BYTE_SIZE)
        pos.copy_into(self._builder.Bytes, self._builder.Head())
        self._builder.PrependStructSlot(0, self._builder.Offset(), 0)

    def add_mana(self, mana):
        self._builder.PrependInt16Slot(1, mana, 150)

    def add_hp(self, hp):
        self._builder.PrependInt16Slot(2, hp, 100)

    def add_name(self, name):
        self._builder.PrependUOffsetTRelativeSlot(3, name, 0)

    def add_inventory(self, inventory):
        self._builder.PrependUOffsetTRelativeSlot(5, inventory, 0)

    @staticmethod
    def start_inventory(builder, number_of_elements):
        return builder.StartVector(1, number_of_elements, 1)

    @staticmethod
    def end_inventory(builder, number_of_elements):
        return builder.EndVector(number_of_elements)

    def add_color(self, color):
        self._builder.PrependInt8Slot(6, color, 2)

    def add_weapons(self, weapons):
        self._builder.PrependUOffsetTRelativeSlot(7, weapons, 0)

    @staticmethod
    def start_weapons(builder, number_of_elements):
        return builder.StartVector(4, number_of_elements, 4)

    @staticmethod
    def end_weapons(builder, number_of_elements):
        return builder.EndVector(number_of_elements)

    def add_equipped_type(self, equipped_type):
        self._builder.PrependUint8Slot(8, equipped_type, 0)

    def add_equipped(self, equipped):
        self._builder.PrependUOffsetTRelativeSlot(9, equipped, 0)

    def finish(self):
        return self._builder.EndObject()


class Weapon(object):
    VT_NAME = 4
    VT_DAMAGE = 6

    def __init__(self, buf, offset):
        self._tab = flatbuffers.table.Table(buf, offset)

    @classmethod
    def from_root(cls, buf, offset=0):
        relative_table_offset = flatbuffers.encode.Get(flatbuffers.packer.uoffset, buf, offset)
        return Weapon(buf, offset + relative_table_offset)

    @property
    def name(self):
        offset = self._tab.Offset(self.VT_NAME)
        if not offset:
            return None

        return self._tab.String(offset + self._tab.Pos)

    @property
    def damage(self):
        offset = self._tab.Offset(self.VT_DAMAGE)
        if not offset:
            return 0

        return self._tab.Get(flatbuffers.number_types.Int16Flags, offset + self._tab.Pos)

    @staticmethod
    def create(fbb, name, damage):
        builder = WeaponBuilder(fbb)
        builder.add_name(name)
        builder.add_damage(damage)
        return builder.finish()


class WeaponBuilder(object):
    def __init__(self, builder):
        self._builder = builder
        builder.StartObject(2)

    def add_name(self, name):
        self._builder.PrependUOffsetTRelativeSlot(0, name, 0)

    def add_damage(self, damage):
        self._builder.PrependInt16Slot(1, damage, 0)

    def finish(self):
        return self._builder.EndObject()
